package pb

import (
	"context"
	"log/slog"
	"net"
	"os"
	"testing"

	ag "github.com/samuelsih/revo-voting/pb/autogenerated"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"
)

func startingServer() (ag.VoteStatusServiceClient, func()) {
	server := Server(getMock(ok))

	ctx := context.Background()

	buffer := 1024 * 1024
	listener := bufconn.Listen(buffer)

	go func() {
		slog.Info("Running server")
		err := server.Serve(listener)
		if err != nil {
			slog.Error("error serving server: %v", err)
			os.Exit(1)
		}
	}()

	conn, err := grpc.DialContext(ctx, "",
		grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {
			return listener.Dial()
		}),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		slog.Error("error connecting to server: %v", err)
		os.Exit(1)
	}

	closer := func() {
		err = listener.Close()
		if err != nil {
			slog.Error("error closing listener: %v", err)
		}

		server.Stop()
	}

	client := ag.NewVoteStatusServiceClient(conn)

	return client, closer
}

func TestServer(t *testing.T) {
	client, closeFunc := startingServer()

	out, err := client.CheckStatus(context.TODO(), &ag.Request{VoteId: "some-id"})
	if err != nil {
		t.Errorf("got error: %v", err)
	}

	if out.Status != "ok" {
		t.Errorf("expecting ok, got %v", out.Status)
	}

	t.Cleanup(closeFunc)
}
